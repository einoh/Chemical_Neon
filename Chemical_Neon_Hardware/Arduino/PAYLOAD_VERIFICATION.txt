/**
 * ARDUINO HMAC PAYLOAD VERIFICATION
 * 
 * This document shows what the Arduino will send and how to verify it matches
 * the server's expected format.
 */

// ============================================
// SAMPLE ARDUINO TRANSMISSION
// ============================================

// When a coin is detected, Arduino sends:
POST /api/hardware/coin HTTP/1.1
Host: 192.168.1.16:5000
Content-Type: application/json
Connection: close
Content-Length: 138

{
  "machineId": "SITE_001",
  "pulseCount": 10,
  "timestamp": "3600",
  "signature": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0e1f2"
}


// ============================================
// SERVER-SIDE VERIFICATION FLOW
// ============================================

1. Server receives the request
2. Extract: machineId, pulseCount, timestamp, signature
3. Verify timestamp is recent (within 5 minutes)
4. Reconstruct message: "SITE_001:10:3600"
5. Compute HMAC-SHA256 with secret key
6. Compare computed signature with received signature
7. If match ? Accept, update credit
8. If mismatch ? Reject with 401 Unauthorized


// ============================================
// TESTING WITH POSTMAN
// ============================================

URL: POST http://192.168.1.16:5000/api/hardware/coin

Headers:
  Content-Type: application/json

Body (Raw JSON):
{
  "machineId": "SITE_001",
  "pulseCount": 5,
  "timestamp": "1704067200",
  "signature": "0e8bb4c3f5c8e1d2a4b6c8e0f2a4c6e8f0a2c4e6f8a0c2e4f6a8c0e2f4a6c8"
}

To generate the correct signature for testing:
- Message: "SITE_001:5:1704067200"
- Secret Key: "dev-secret-key-change-before-production"
- Hash: HMAC-SHA256(message, secretKey)
- Result (hex): 0e8bb4c3f5c8e1d2a4b6c8e0f2a4c6e8f0a2c4e6f8a0c2e4f6a8c0e2f4a6c8


// ============================================
// ARDUINO SERIAL MONITOR OUTPUT
// ============================================

When Arduino detects coins, you'll see:

========================================
Wi-Fi Vendo v3 - HMAC Secured
========================================
Initializing Ethernet...
? Connected! Device IP: 192.168.1.100
? Server: 192.168.1.16:5000
? Machine ID: SITE_001
Ready for coins!

?? Sending 10 pulses...
   Message: SITE_001:10:3600
   Signature: a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0e1f2
   Payload size: 138 bytes
? Data sent successfully!


// ============================================
// TROUBLESHOOTING
// ============================================

ISSUE: "Connection Failed. Check Server IP/Port"
- Verify Arduino can ping the server
- Check firewall rules on server
- Verify port 5000 is open and .NET is listening

ISSUE: Server returns 401 Unauthorized
- Signature mismatch (wrong secret key)
- Timestamp too old (>5 minutes)
- Message format incorrect

ISSUE: Server returns 400 Bad Request
- Machine not found in database
- Machine not locked
- Invalid timestamp format

ISSUE: Signature looks wrong
- Check that hmacSecretKey in Arduino matches appsettings.json
- Verify message format: "machineId:pulseCount:timestamp"
- Ensure no extra spaces or quotes


// ============================================
// NETWORK TROUBLESHOOTING
// ============================================

If Arduino can't connect to server:

1. Check Arduino IP:
   - Serial monitor will show: "Device IP: 192.168.1.100"
   - Should be on same network as server

2. Check server is listening:
   - On .NET server, verify port 5000 is open
   - netstat -an | findstr :5000 (Windows)
   - lsof -i :5000 (Linux/Mac)

3. Test connectivity with ping:
   - From Arduino network: ping 192.168.1.16

4. Check firewall:
   - Windows Firewall: Allow port 5000
   - Third-party firewall: Open port 5000


// ============================================
// PRODUCTION CONSIDERATIONS
// ============================================

1. TIMESTAMP SYNCHRONIZATION
   - Current implementation uses millis() (drifts over time)
   - For production, implement NTP synchronization
   - Arduino Time library: https://github.com/PaulStoffregen/Time
   - Ethernet library Time: https://github.com/PaulStoffregen/EthernetBonjour

2. SECRET KEY MANAGEMENT
   - Don't hardcode secret in Arduino code
   - Consider EEPROM storage for key
   - Implement key rotation mechanism
   - Use different keys per machine

3. SECURE COMMUNICATION
   - Upgrade to HTTPS if possible
   - Current implementation uses plain HTTP (acceptable for LAN)
   - For public networks, MUST use HTTPS

4. REPLAY ATTACK PREVENTION
   - Current implementation: 5-minute timestamp tolerance
   - Server must validate timestamps
   - Consider nonce-based approach for higher security
